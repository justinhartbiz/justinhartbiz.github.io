<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Non-Newtonian Fluids: Breaking Physics Rules</title>
    <style>
        /* Typography */
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap');

        /* Base Styles */
        :root {
            --bg-color: #030305;
            --gold-accent: #FFD28E;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.36);
            --panel-radius: 12px;
            --transition-time: 0.3s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: 'Playfair Display', serif;
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
        }

        h1, h2, h3 {
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--gold-accent);
        }

        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin: 2rem 0;
            text-shadow: 0 0 10px rgba(255, 210, 142, 0.3);
        }

        h2 {
            font-size: 1.8rem;
            border-bottom: 1px solid var(--gold-accent);
            padding-bottom: 0.5rem;
            margin-top: 2rem;
        }

        h3 {
            font-size: 1.4rem;
            margin-top: 1.5rem;
        }

        p, li {
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        code, pre {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        /* Starfield Background */
        .starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            overflow: hidden;
        }

        /* Glassmorphism Panel */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border);
            border-radius: var(--panel-radius);
            box-shadow: var(--glass-shadow);
            padding: 2rem;
            margin-bottom: 2rem;
            transition: transform var(--transition-time), box-shadow var(--transition-time);
        }

        .glass-panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.5);
        }

        /* Button Styles */
        button {
            background: rgba(255, 210, 142, 0.1);
            color: var(--gold-accent);
            border: 1px solid var(--gold-accent);
            border-radius: 4px;
            padding: 0.5rem 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            cursor: pointer;
            transition: all var(--transition-time);
            margin: 0.5rem;
        }

        button:hover, button.active {
            background: var(--gold-accent);
            color: var(--bg-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Interactive Elements */
        .interactive-section {
            margin: 2rem 0;
        }

        .canvas-container {
            width: 100%;
            height: 300px;
            margin: 1rem 0;
            position: relative;
            overflow: hidden;
            border-radius: var(--panel-radius);
        }

        canvas {
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--panel-radius);
            touch-action: none;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
        }

        /* Quiz Section */
        .quiz-container {
            display: none;
        }

        .quiz-container.active {
            display: block;
        }

        .question {
            margin-bottom: 1.5rem;
        }

        .options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 600px) {
            .options {
                grid-template-columns: 1fr;
            }
        }

        .option {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            padding: 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option:hover {
            background: rgba(255, 210, 142, 0.1);
        }

        .option.selected {
            background: var(--gold-accent);
            color: var(--bg-color);
        }

        .option.correct {
            background: rgba(0, 255, 0, 0.2);
            border-color: rgba(0, 255, 0, 0.4);
        }

        .option.incorrect {
            background: rgba(255, 0, 0, 0.2);
            border-color: rgba(255, 0, 0, 0.4);
        }

        .result {
            margin: 1rem 0;
            padding: 1rem;
            border-radius: 4px;
            text-align: center;
            display: none;
        }

        /* Fluid Type Card */
        .fluid-card {
            border: 1px solid var(--glass-border);
            border-radius: var(--panel-radius);
            padding: 1rem;
            margin-bottom: 1rem;
            background: rgba(0, 0, 0, 0.2);
        }

        .fluid-card h4 {
            color: var(--gold-accent);
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            padding: 0.5rem;
            border-bottom: 1px solid var(--glass-border);
            text-align: left;
        }

        th {
            color: var(--gold-accent);
            font-weight: bold;
            background: rgba(0, 0, 0, 0.2);
        }

        /* Responsive adjustments */
        @media screen and (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .glass-panel {
                padding: 1.5rem;
            }
        }

        /* Drag simulator specific */
        .draggable {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: var(--gold-accent);
            border-radius: 50%;
            cursor: grab;
            user-select: none;
            touch-action: none;
        }

        .draggable:active {
            cursor: grabbing;
        }

        /* Identify the fluid game */
        .fluid-image {
            width: 100%;
            height: 180px;
            border-radius: var(--panel-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            color: white;
            font-size: 1.2rem;
            background-color: rgba(0, 0, 0, 0.3);
        }

        /* Score display */
        .score {
            font-family: 'JetBrains Mono', monospace;
            text-align: right;
            margin-bottom: 1rem;
            color: var(--gold-accent);
        }
    </style>
</head>
<body>
    <!-- Starfield Background -->
    <div class="starfield" id="starfield"></div>

    <div class="container">
        <h1>NON-NEWTONIAN FLUIDS</h1>
        <p class="glass-panel" style="text-align: center; font-style: italic;">Liquids that break the rules of physics</p>

        <!-- Introduction Section -->
        <section id="intro" class="glass-panel">
            <h2>Introduction</h2>
            <p>
                Non-Newtonian fluids are materials that don't follow Newton's law of viscosity. Unlike water or oil, their viscosity (thickness) changes based on the force applied to them or over time. They seem to defy intuition—turning from liquid to solid in an instant, or flowing more easily when stressed.
            </p>
            <p>
                These fascinating substances are all around us, from ketchup and toothpaste to quicksand and blood. They showcase the remarkable boundary between different states of matter and have numerous practical applications in fields ranging from food science to military technology.
            </p>
        </section>

        <!-- Types of Non-Newtonian Fluids -->
        <section id="types" class="glass-panel">
            <h2>Types of Non-Newtonian Fluids</h2>
            
            <div class="fluid-card">
                <h4>Shear-Thickening (Dilatant)</h4>
                <p>These fluids increase in viscosity when stress is applied. The classic example is <strong>oobleck</strong> (cornstarch and water), which allows you to run across its surface but will sink you if you stand still.</p>
                <p><em>Examples: Cornstarch solutions, silly putty under impact, concentrated particle suspensions.</em></p>
            </div>

            <div class="fluid-card">
                <h4>Shear-Thinning (Pseudoplastic)</h4>
                <p>These fluids decrease in viscosity when stress is applied. They flow more easily when you apply force.</p>
                <p><em>Examples: Ketchup, paint, blood, many polymer solutions.</em></p>
            </div>

            <div class="fluid-card">
                <h4>Thixotropic</h4>
                <p>These time-dependent fluids become less viscous over time when shaken, agitated, or stressed, and then thicken again when allowed to rest.</p>
                <p><em>Examples: Yogurt, quicksand, some clay suspensions, printer ink.</em></p>
            </div>

            <div class="fluid-card">
                <h4>Rheopectic</h4>
                <p>These rare, time-dependent fluids increase in viscosity the longer stress is applied. The opposite of thixotropic fluids.</p>
                <p><em>Examples: Some lubricants, cream whipped for extended periods, gypsum suspensions.</em></p>
            </div>

            <div class="fluid-card">
                <h4>Bingham Plastic</h4>
                <p>These fluids behave as solids at low stress but flow as viscous fluids at high stress. They have a yield stress threshold.</p>
                <p><em>Examples: Toothpaste, mayonnaise, drilling mud, certain cosmetics.</em></p>
            </div>
        </section>

        <!-- Physics Behind Non-Newtonian Fluids -->
        <section id="physics" class="glass-panel">
            <h2>The Physics: Jamming vs. Flowing</h2>
            <p>
                The unusual behavior of non-Newtonian fluids emerges from their microstructure. Most contain particles, polymers, or other components suspended in a liquid medium.
            </p>
            
            <h3>Key Mechanisms:</h3>
            <ul>
                <li><strong>Particle Chain Formation:</strong> In shear-thickening fluids like oobleck, rapid stress causes suspended particles to form temporary chain-like structures that resist motion.</li>
                <li><strong>Molecular Alignment:</strong> In shear-thinning fluids, long polymer chains align in the direction of flow when stressed, reducing resistance.</li>
                <li><strong>Weak Bonds Breaking/Forming:</strong> Thixotropic and rheopectic fluids involve temporary bonds between particles that form or break over time.</li>
                <li><strong>Yield Stress:</strong> Bingham plastics maintain a 3D network structure that must be overcome by a minimum force before flow begins.</li>
            </ul>

            <p>
                These mechanisms create the fascinating transition between solid-like and liquid-like behavior that makes non-Newtonian fluids so counterintuitive and useful.
            </p>
        </section>

        <!-- Real-World Applications -->
        <section id="applications" class="glass-panel">
            <h2>Applications</h2>
            
            <h3>Protective Equipment</h3>
            <p>
                Shear-thickening fluids are used in liquid body armor. Under normal conditions, these materials remain flexible for comfort. Upon impact (like a bullet or knife), they instantly harden to absorb and distribute energy, providing superior protection while maintaining mobility.
            </p>

            <h3>Food Science</h3>
            <p>
                Non-Newtonian properties are crucial in food processing and formulation:
            </p>
            <ul>
                <li>Ketchup (shear-thinning): Stays in the bottle until shaken, then flows easily</li>
                <li>Mayonnaise (Bingham plastic): Holds its shape on a plate but spreads easily with a knife</li>
                <li>Ice cream: Air incorporation during churning creates complex rheological properties</li>
            </ul>

            <h3>3D Printing</h3>
            <p>
                Shear-thinning fluids make ideal 3D printing materials. They flow easily through the nozzle under pressure but maintain their shape after deposition, allowing for complex structures to be built layer by layer without collapsing.
            </p>

            <h3>Medicine</h3>
            <p>
                Blood is a non-Newtonian fluid, thinning when flowing quickly through arteries and thickening when flowing slowly through capillaries. Understanding these properties is crucial for treating circulatory disorders and designing artificial vessels.
            </p>

            <h3>Industrial Applications</h3>
            <ul>
                <li>Drilling fluids in oil extraction</li>
                <li>Concrete pumping</li>
                <li>Paint formulation and application</li>
                <li>Ceramic processing</li>
            </ul>
        </section>

        <!-- Interactive Section: Punch the Pool -->
        <section id="punch-pool" class="glass-panel interactive-section">
            <h2>Interactive: Punch the Pool</h2>
            <p>Click or tap the oobleck pool below. The harder/faster you tap, the more resistance you'll encounter!</p>
            
            <div class="canvas-container">
                <canvas id="poolCanvas"></canvas>
            </div>

            <div class="controls">
                <button id="resetPool">Reset Pool</button>
                <span id="forceDisplay" style="color: var(--gold-accent); margin-left: 1rem; font-family: 'JetBrains Mono', monospace;"></span>
            </div>
        </section>

        <!-- Interactive Section: Viscosity Spectrum -->
        <section id="viscosity-spectrum" class="glass-panel interactive-section">
            <h2>Interactive: Viscosity Spectrum</h2>
            <p>Drag the circle through different fluids and feel how they respond differently to your movements.</p>
            
            <div class="canvas-container" id="dragContainer">
                <canvas id="viscosityCanvas"></canvas>
            </div>

            <div class="controls">
                <button class="fluid-btn active" data-fluid="newtonian">Newtonian (Water)</button>
                <button class="fluid-btn" data-fluid="shear-thickening">Shear-Thickening</button>
                <button class="fluid-btn" data-fluid="shear-thinning">Shear-Thinning</button>
                <button class="fluid-btn" data-fluid="bingham">Bingham Plastic</button>
            </div>
        </section>

        <!-- Interactive Section: Identify the Fluid -->
        <section id="identify-game" class="glass-panel interactive-section">
            <h2>Interactive: Identify the Fluid</h2>
            <p>Watch how the fluid behaves and identify which type of non-Newtonian fluid it is.</p>
            
            <div class="fluid-image" id="fluidAnimation">
                <div id="fluidDemoText">Press Start to begin</div>
            </div>

            <div class="controls">
                <button id="startFluidGame">Start</button>
            </div>

            <div id="fluidOptions" style="display: none;">
                <div class="options">
                    <button class="fluid-option" data-option="shear-thickening">Shear-Thickening</button>
                    <button class="fluid-option" data-option="shear-thinning">Shear-Thinning</button>
                    <button class="fluid-option" data-option="thixotropic">Thixotropic</button>
                    <button class="fluid-option" data-option="rheopectic">Rheopectic</button>
                    <button class="fluid-option" data-option="bingham">Bingham Plastic</button>
                </div>
            </div>

            <div class="score" id="fluidGameScore">Score: 0/0</div>
        </section>

        <!-- Quiz Section -->
        <section id="quiz" class="glass-panel">
            <h2>Test Your Knowledge: Non-Newtonian Quiz</h2>
            <p>Let's see how much you've learned about these fascinating fluids!</p>
            
            <button id="startQuiz">Start Quiz</button>
            
            <div id="quizContainer" class="quiz-container">
                <div id="questionContainer"></div>
                <div class="controls">
                    <button id="submitAnswer" disabled>Submit Answer</button>
                    <button id="nextQuestion" style="display: none;">Next Question</button>
                </div>
                <div id="result" class="result"></div>
            </div>
        </section>

        <!-- Real-world Examples Quiz -->
        <section id="examples-quiz" class="glass-panel">
            <h2>Everyday Non-Newtonian Fluids</h2>
            <p>Can you match these everyday products with their non-Newtonian fluid type?</p>
            
            <button id="startExamplesQuiz">Start Examples Quiz</button>
            
            <div id="examplesContainer" class="quiz-container">
                <div id="exampleQuestionContainer"></div>
                <div class="controls">
                    <button id="submitExampleAnswer" disabled>Submit Answer</button>
                    <button id="nextExample" style="display: none;">Next Example</button>
                </div>
                <div id="exampleResult" class="result"></div>
            </div>
        </section>

        <!-- Resources Section -->
        <section id="resources" class="glass-panel">
            <h2>Learn More</h2>
            <p>If you want to learn more about non-Newtonian fluids, here are some great resources:</p>
            <ul>
                <li>Make your own oobleck: Mix 1 part water with 1.5-2 parts cornstarch</li>
                <li>Book: "Rheology: Principles, Measurements, and Applications" by Christopher W. Macosko</li>
                <li>The Journal of Rheology, published by the Society of Rheology</li>
                <li>MIT OpenCourseWare: Fluid Dynamics lectures</li>
            </ul>
        </section>

        <footer class="glass-panel" style="text-align: center; margin-top: 2rem;">
            <p style="margin-bottom: 0;">© 2026 Justin Hart | Created for justinhart.biz</p>
        </footer>
    </div>

    <!-- Scripts -->
    <script>
        // ========== Starfield Background ==========
        (function createStarfield() {
            const starfield = document.getElementById('starfield');
            const stars = 400; // Number of stars

            for (let i = 0; i < stars; i++) {
                const star = document.createElement('div');
                star.style.position = 'absolute';
                star.style.width = `${Math.random() * 2}px`;
                star.style.height = star.style.width;
                star.style.backgroundColor = 'white';
                star.style.borderRadius = '50%';
                star.style.opacity = Math.random() * 0.7 + 0.3;
                star.style.top = `${Math.random() * 100}%`;
                star.style.left = `${Math.random() * 100}%`;
                star.style.animation = `twinkle ${Math.random() * 5 + 5}s infinite`;
                starfield.appendChild(star);
            }

            // Add CSS animation for twinkling
            const style = document.createElement('style');
            style.textContent = `
                @keyframes twinkle {
                    0% { opacity: ${Math.random() * 0.5 + 0.3}; }
                    50% { opacity: ${Math.random() * 0.3 + 0.7}; }
                    100% { opacity: ${Math.random() * 0.5 + 0.3}; }
                }
            `;
            document.head.appendChild(style);
        })();

        // ========== Punch the Pool Simulator ==========
        (function createPunchPool() {
            const canvas = document.getElementById('poolCanvas');
            const ctx = canvas.getContext('2d');
            const resetBtn = document.getElementById('resetPool');
            const forceDisplay = document.getElementById('forceDisplay');
            
            let particles = [];
            let lastTime = 0;
            let isPoking = false;
            let pokePosition = { x: 0, y: 0 };
            let pokeVelocity = 0;
            let pokeForce = 0;
            let pokeStartTime = 0;
            
            // Resize canvas
            function resizeCanvas() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                initParticles();
            }

            // Create initial particles
            function initParticles() {
                particles = [];
                const particleCount = Math.floor(canvas.width * canvas.height / 300);
                
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 4 + 2,
                        color: `rgba(255, 210, 142, ${Math.random() * 0.5 + 0.5})`,
                        vx: 0,
                        vy: 0
                    });
                }
            }

            // Draw function
            function draw(timestamp) {
                if (!lastTime) lastTime = timestamp;
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw fluid surface
                ctx.fillStyle = 'rgba(255, 210, 142, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Update and draw particles
                for (let particle of particles) {
                    if (isPoking) {
                        const dx = particle.x - pokePosition.x;
                        const dy = particle.y - pokePosition.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 80) {
                            // Apply force based on poking strength and distance
                            const force = (pokeForce / (distance + 10)) * 30;
                            const angle = Math.atan2(dy, dx);
                            particle.vx += Math.cos(angle) * force * deltaTime;
                            particle.vy += Math.sin(angle) * force * deltaTime;
                        }
                    }
                    
                    // Apply fluid resistance (thickening under stress)
                    const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                    const resistance = Math.min(speed * speed * 0.1 + 0.5, 0.98);
                    
                    particle.vx *= (1 - resistance * deltaTime);
                    particle.vy *= (1 - resistance * deltaTime);
                    
                    // Update position
                    particle.x += particle.vx * deltaTime * 60;
                    particle.y += particle.vy * deltaTime * 60;
                    
                    // Boundary check
                    if (particle.x < 0) {
                        particle.x = 0;
                        particle.vx *= -0.5;
                    }
                    if (particle.x > canvas.width) {
                        particle.x = canvas.width;
                        particle.vx *= -0.5;
                    }
                    if (particle.y < 0) {
                        particle.y = 0;
                        particle.vy *= -0.5;
                    }
                    if (particle.y > canvas.height) {
                        particle.y = canvas.height;
                        particle.vy *= -0.5;
                    }
                    
                    // Draw particle
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color;
                    ctx.fill();
                }
                
                // Draw poke impact
                if (isPoking) {
                    const radius = 20 + pokeForce * 20;
                    const gradient = ctx.createRadialGradient(
                        pokePosition.x, pokePosition.y, 0,
                        pokePosition.x, pokePosition.y, radius
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 210, 142, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 210, 142, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(pokePosition.x, pokePosition.y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Gradually reduce poking effect
                    pokeForce *= 0.95;
                    if (pokeForce < 0.01) {
                        isPoking = false;
                        forceDisplay.textContent = '';
                    }
                }
                
                requestAnimationFrame(draw);
            }

            // Event handlers
            function handlePointerDown(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                pokeStartTime = Date.now();
                pokePosition = { x, y };
                pokeVelocity = 0;
            }

            function handlePointerMove(e) {
                if (pokeStartTime === 0) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const dx = x - pokePosition.x;
                const dy = y - pokePosition.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const dt = (Date.now() - pokeStartTime) / 1000;
                
                if (dt > 0) {
                    pokeVelocity = distance / dt;
                }
                
                pokePosition = { x, y };
            }

            function handlePointerUp(e) {
                if (pokeStartTime === 0) return;
                
                const dt = (Date.now() - pokeStartTime) / 1000;
                const velocity = pokeVelocity / (dt + 0.1);
                pokeForce = Math.min(Math.max(velocity / 50, 0.1), 3);
                
                isPoking = true;
                pokeStartTime = 0;
                
                // Display force feedback
                const forcePercentage = Math.round(pokeForce * 100 / 3);
                forceDisplay.textContent = `Impact force: ${forcePercentage}%`;
                
                // Add rapid ripple effect based on force
                const rippleCount = Math.floor(pokeForce * 15);
                for (let i = 0; i < rippleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 30 * pokeForce;
                    const x = pokePosition.x + Math.cos(angle) * distance;
                    const y = pokePosition.y + Math.sin(angle) * distance;
                    
                    particles.push({
                        x,
                        y,
                        radius: Math.random() * 4 + 2,
                        color: `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`,
                        vx: Math.cos(angle) * pokeForce * 30,
                        vy: Math.sin(angle) * pokeForce * 30
                    });
                }
            }

            // Touch events for mobile
            function handleTouchStart(e) {
                e.preventDefault();
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    const fakeEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    };
                    handlePointerDown(fakeEvent);
                }
            }

            function handleTouchMove(e) {
                e.preventDefault();
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    const fakeEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    };
                    handlePointerMove(fakeEvent);
                }
            }

            function handleTouchEnd(e) {
                e.preventDefault();
                handlePointerUp({});
            }

            // Initialize and setup
            canvas.addEventListener('mousedown', handlePointerDown);
            canvas.addEventListener('mousemove', handlePointerMove);
            canvas.addEventListener('mouseup', handlePointerUp);
            canvas.addEventListener('mouseleave', handlePointerUp);
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            resetBtn.addEventListener('click', function() {
                isPoking = false;
                initParticles();
                forceDisplay.textContent = '';
            });

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            requestAnimationFrame(draw);
        })();

        // ========== Viscosity Spectrum Simulator ==========
        (function createViscositySimulator() {
            const canvas = document.getElementById('viscosityCanvas');
            const ctx = canvas.getContext('2d');
            const fluidButtons = document.querySelectorAll('.fluid-btn');
            
            let dragging = false;
            let currentFluidType = 'newtonian';
            let particle = {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                radius: 20
            };
            
            let particles = [];
            let lastMousePos = { x: 0, y: 0 };
            let mousePos = { x: 0, y: 0 };
            let mouseVelocity = { x: 0, y: 0 };
            let lastTime = 0;
            
            // Fluid properties
            const fluids = {
                'newtonian': {
                    color: 'rgba(100, 149, 237, 0.7)',
                    viscosity: 0.2,
                    threshold: 0,
                    thickeningFactor: 0,
                    thinningFactor: 0,
                    label: 'Water'
                },
                'shear-thickening': {
                    color: 'rgba(255, 255, 255, 0.7)',
                    viscosity: 0.05,
                    threshold: 5,
                    thickeningFactor: 0.1,
                    thinningFactor: 0,
                    label: 'Oobleck'
                },
                'shear-thinning': {
                    color: 'rgba(220, 20, 60, 0.7)',
                    viscosity: 0.6,
                    threshold: 3,
                    thickeningFactor: 0,
                    thinningFactor: 0.2,
                    label: 'Ketchup'
                },
                'bingham': {
                    color: 'rgba(255, 255, 255, 0.7)',
                    viscosity: 0.9,
                    threshold: 8,
                    thickeningFactor: 0,
                    thinningFactor: 0.7,
                    yieldStress: 3,
                    label: 'Toothpaste'
                }
            };
            
            // Resize canvas
            function resizeCanvas() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                particle.x = canvas.width / 2;
                particle.y = canvas.height / 2;
                initBackgroundParticles();
            }
            
            // Create background particles
            function initBackgroundParticles() {
                particles = [];
                const particleCount = Math.floor(canvas.width * canvas.height / 800);
                
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 3 + 1,
                        color: fluids[currentFluidType].color,
                        vx: 0,
                        vy: 0,
                        original: { x: Math.random() * canvas.width, y: Math.random() * canvas.height }
                    });
                }
            }
            
            // Update fluid visualization
            function updateFluidVisualization() {
                for (const p of particles) {
                    p.color = fluids[currentFluidType].color;
                }
            }
            
            // Draw function
            function draw(timestamp) {
                if (!lastTime) lastTime = timestamp;
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw fluid background
                ctx.fillStyle = fluids[currentFluidType].color.replace('0.7', '0.2');
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Calculate mouse velocity
                if (dragging) {
                    mouseVelocity.x = (mousePos.x - lastMousePos.x) / deltaTime;
                    mouseVelocity.y = (mousePos.y - lastMousePos.y) / deltaTime;
                    lastMousePos.x = mousePos.x;
                    lastMousePos.y = mousePos.y;
                } else {
                    mouseVelocity.x *= 0.95;
                    mouseVelocity.y *= 0.95;
                }
                
                const mouseSpeed = Math.sqrt(mouseVelocity.x * mouseVelocity.x + mouseVelocity.y * mouseVelocity.y);
                
                // Update draggable particle physics
                if (dragging) {
                    particle.x = mousePos.x;
                    particle.y = mousePos.y;
                    particle.vx = mouseVelocity.x;
                    particle.vy = mouseVelocity.y;
                } else {
                    // Apply fluid physics
                    const fluid = fluids[currentFluidType];
                    let viscosity = fluid.viscosity;
                    const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                    
                    // Shear-thickening effect
                    if (fluid.thickeningFactor > 0 && speed > fluid.threshold) {
                        viscosity += (speed - fluid.threshold) * fluid.thickeningFactor;
                    }
                    
                    // Shear-thinning effect
                    if (fluid.thinningFactor > 0 && speed > fluid.threshold) {
                        viscosity -= Math.min(viscosity * 0.9, (speed - fluid.threshold) * fluid.thinningFactor);
                        viscosity = Math.max(0.02, viscosity);
                    }
                    
                    // Bingham plastic yield stress
                    if (fluid.yieldStress && speed < fluid.yieldStress) {
                        particle.vx *= 0.7;
                        particle.vy *= 0.7;
                        if (speed < 0.5) {
                            particle.vx = 0;
                            particle.vy = 0;
                        }
                    }
                    
                    // Apply viscosity drag
                    particle.vx *= (1 - viscosity * deltaTime * 3);
                    particle.vy *= (1 - viscosity * deltaTime * 3);
                    
                    // Add gravity for realism
                    particle.vy += 9.8 * deltaTime * 0.5;
                    
                    // Update position
                    particle.x += particle.vx * deltaTime * 60;
                    particle.y += particle.vy * deltaTime * 60;
                    
                    // Boundary check
                    if (particle.x < particle.radius) {
                        particle.x = particle.radius;
                        particle.vx *= -0.7;
                    } else if (particle.x > canvas.width - particle.radius) {
                        particle.x = canvas.width - particle.radius;
                        particle.vx *= -0.7;
                    }
                    
                    if (particle.y < particle.radius) {
                        particle.y = particle.radius;
                        particle.vy *= -0.7;
                    } else if (particle.y > canvas.height - particle.radius) {
                        particle.y = canvas.height - particle.radius;
                        particle.vy *= -0.7;
                    }
                }
                
                // Update background particles
                for (const p of particles) {
                    const dx = particle.x - p.x;
                    const dy = particle.y - p.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < particle.radius * 3) {
                        const force = (particle.radius * 3 - distance) / (particle.radius * 3) * 0.2;
                        const angle = Math.atan2(dy, dx);
                        p.vx += Math.cos(angle) * force * (Math.abs(particle.vx) + Math.abs(particle.vy)) * 0.05;
                        p.vy += Math.sin(angle) * force * (Math.abs(particle.vx) + Math.abs(particle.vy)) * 0.05;
                    }
                    
                    // Attract particles back to original positions
                    const dxOrig = p.original.x - p.x;
                    const dyOrig = p.original.y - p.y;
                    p.vx += dxOrig * 0.01 * deltaTime;
                    p.vy += dyOrig * 0.01 * deltaTime;
                    
                    // Apply fluid resistance
                    p.vx *= 0.97;
                    p.vy *= 0.97;
                    
                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Draw background particle
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                }
                
                // Draw the main draggable particle
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD28E';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw speed indicator lines
                if (Math.abs(particle.vx) > 0.1 || Math.abs(particle.vy) > 0.1) {
                    const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                    const speedFactor = Math.min(speed / 15, 1);
                    const lineLength = particle.radius * (1 + speedFactor * 2);
                    
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const dirX = Math.cos(angle);
                        const dirY = Math.sin(angle);
                        
                        ctx.beginPath();
                        ctx.moveTo(
                            particle.x + dirX * particle.radius,
                            particle.y + dirY * particle.radius
                        );
                        ctx.lineTo(
                            particle.x + dirX * lineLength,
                            particle.y + dirY * lineLength
                        );
                        ctx.strokeStyle = `rgba(255, 210, 142, ${speedFactor * 0.8})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
                
                // Draw fluid label
                ctx.fillStyle = 'white';
                ctx.font = '18px "JetBrains Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(fluids[currentFluidType].label, canvas.width / 2, 30);
                
                // Draw speed indicator
                const particleSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                ctx.fillStyle = 'rgba(255, 210, 142, 0.8)';
                ctx.font = '14px "JetBrains Mono", monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Speed: ${Math.round(particleSpeed)}`, 10, canvas.height - 10);
                
                requestAnimationFrame(draw);
            }
            
            // Event handlers
            function handlePointerDown(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const dx = x - particle.x;
                const dy = y - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < particle.radius * 2) {
                    dragging = true;
                    mousePos = { x, y };
                    lastMousePos = { x, y };
                }
            }
            
            function handlePointerMove(e) {
                if (!dragging) return;
                
                const rect = canvas.getBoundingClientRect();
                mousePos.x = e.clientX - rect.left;
                mousePos.y = e.clientY - rect.top;
            }
            
            function handlePointerUp() {
                dragging = false;
            }
            
            // Touch events for mobile
            function handleTouchStart(e) {
                e.preventDefault();
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    const fakeEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    };
                    handlePointerDown(fakeEvent);
                }
            }
            
            function handleTouchMove(e) {
                e.preventDefault();
                if (dragging && e.touches.length > 0) {
                    const touch = e.touches[0];
                    const fakeEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    };
                    handlePointerMove(fakeEvent);
                }
            }
            
            function handleTouchEnd(e) {
                e.preventDefault();
                handlePointerUp();
            }
            
            // Initialize and setup
            canvas.addEventListener('mousedown', handlePointerDown);
            window.addEventListener('mousemove', handlePointerMove);
            window.addEventListener('mouseup', handlePointerUp);
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            fluidButtons.forEach(button => {
                button.addEventListener('click', () => {
                    fluidButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    currentFluidType = button.dataset.fluid;
                    updateFluidVisualization();
                });
            });
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            requestAnimationFrame(draw);
        })();

        // ========== Identify the Fluid Game ==========
        (function createIdentifyGame() {
            const fluidAnimation = document.getElementById('fluidAnimation');
            const fluidDemoText = document.getElementById('fluidDemoText');
            const startButton = document.getElementById('startFluidGame');
            const fluidOptions = document.getElementById('fluidOptions');
            const fluidOptionButtons = document.querySelectorAll('.fluid-option');
            const scoreDisplay = document.getElementById('fluidGameScore');
            
            let currentFluid = null;
            let score = { correct: 0, total: 0 };
            let gameActive = false;
            let animationFrame = null;
            
            // Fluid animations - functions that visually represent each fluid type
            const fluidAnimations = {
                'shear-thickening': (ctx, width, height, time) => {
                    const particles = [];
                    const clickStrength = Math.sin(time * 3) * 0.5 + 0.5; // Simulate a "tap"
                    
                    // Generate particles
                    for (let i = 0; i < 100; i++) {
                        particles.push({
                            x: Math.random() * width,
                            y: Math.random() * height,
                            radius: Math.random() * 3 + 2,
                            color: `rgba(255, 255, 255, ${Math.random() * 0.7 + 0.3})`,
                        });
                    }
                    
                    // Draw background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Draw impact
                    const impactX = width / 2;
                    const impactY = height / 2;
                    const impactRadius = 50 * clickStrength;
                    
                    // Draw solidifying effect
                    const gradient = ctx.createRadialGradient(
                        impactX, impactY, 0,
                        impactX, impactY, impactRadius * 2
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${clickStrength * 0.9})`);
                    gradient.addColorStop(0.6, `rgba(255, 255, 255, ${clickStrength * 0.3})`);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(impactX, impactY, impactRadius * 2, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Draw particles with displacement based on click
                    for (const particle of particles) {
                        const dx = particle.x - impactX;
                        const dy = particle.y - impactY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < impactRadius) {
                            const displacement = (1 - distance / impactRadius) * 10 * clickStrength;
                            ctx.beginPath();
                            ctx.arc(
                                particle.x + (dx / distance) * displacement,
                                particle.y + (dy / distance) * displacement,
                                particle.radius * (1 + clickStrength),
                                0, Math.PI * 2
                            );
                        } else {
                            ctx.beginPath();
                            ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                        }
                        ctx.fillStyle = particle.color;
                        ctx.fill();
                    }
                    
                    // Draw explanatory text
                    ctx.fillStyle = 'white';
                    ctx.font = '14px "JetBrains Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Applying impact...`, width / 2, height - 20);
                    
                    return clickStrength > 0.8 ? "Solid under impact!" : "Liquid when resting";
                },
                
                'shear-thinning': (ctx, width, height, time) => {
                    ctx.fillStyle = 'rgba(220, 20, 60, 0.7)';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Simulate ketchup flow based on shaking (time)
                    const shakeStrength = Math.sin(time * 3) * 0.5 + 0.5;
                    
                    // Draw ketchup bottle
                    ctx.fillStyle = '#8B0000';
                    ctx.beginPath();
                    ctx.roundRect(width / 2 - 40, 20, 80, 100, 10);
                    ctx.fill();
                    
                    // Draw bottle neck
                    ctx.fillStyle = '#5A0000';
                    ctx.beginPath();
                    ctx.roundRect(width / 2 - 20, 5, 40, 30, 5);
                    ctx.fill();
                    
                    // Draw cap
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(width / 2, 10, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw ketchup flow
                    const flowHeight = 100 + shakeStrength * 100;
                    const gradient = ctx.createLinearGradient(0, 120, 0, 120 + flowHeight);
                    gradient.addColorStop(0, 'rgba(220, 20, 60, 0.9)');
                    gradient.addColorStop(1, 'rgba(220, 20, 60, 0.5)');
                    
                    ctx.fillStyle = gradient;
                    
                    // Draw flow path
                    ctx.beginPath();
                    ctx.moveTo(width / 2, 120);
                    
                    // Make flow more wavy based on shake
                    const flowWidth = 20 + shakeStrength * 10;
                    const waveFrequency = 0.1 + shakeStrength * 0.2;
                    
                    // Create a wavy path
                    const steps = 20;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const y = 120 + flowHeight * t;
                        const x = width / 2 + Math.sin(t * 10 + time * 5) * flowWidth * t;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    // Complete the flow path
                    ctx.lineTo(width / 2 + flowWidth, 120 + flowHeight);
                    ctx.lineTo(width / 2 - flowWidth, 120 + flowHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw explanatory text
                    ctx.fillStyle = 'white';
                    ctx.font = '14px "JetBrains Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Shaking bottle...`, width / 2, height - 20);
                    
                    return shakeStrength > 0.7 ? "Flows easier when stressed!" : "Thick when still";
                },
                
                'thixotropic': (ctx, width, height, time) => {
                    // Simulate quicksand behavior
                    const cyclePos = (Math.sin(time * 0.5) + 1) / 2; // 0 to 1 cycle
                    const agitation = cyclePos < 0.5 ? cyclePos * 2 : 2 - cyclePos * 2; // Agitation phase
                    const settling = cyclePos > 0.5 ? (cyclePos - 0.5) * 2 : 0; // Settling phase
                    
                    // Draw sand layers
                    const layerCount = 15;
                    const layerHeight = height / layerCount;
                    
                    // Create distortion pattern based on agitation
                    for (let i = 0; i < layerCount; i++) {
                        const y = i * layerHeight;
                        const distortFactor = (i / layerCount) * 20 * agitation;
                        const alpha = 0.2 + (i / layerCount) * 0.6;
                        const wavePhase = time * 2 + i * 0.2;
                        
                        ctx.fillStyle = `rgba(210, 180, 140, ${alpha})`;
                        ctx.beginPath();
                        
                        // Create wavy pattern
                        ctx.moveTo(0, y);
                        for (let x = 0; x < width; x += 10) {
                            const distortion = Math.sin(x * 0.03 + wavePhase) * distortFactor;
                            ctx.lineTo(x, y + distortion);
                        }
                        ctx.lineTo(width, y);
                        ctx.lineTo(width, y + layerHeight + 5);
                        ctx.lineTo(0, y + layerHeight + 5);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Draw a sinking object in quicksand
                    const objectY = height * 0.3 + settling * height * 0.4;
                    
                    // Draw disturbed area around the object
                    const disturbRadius = 60 - settling * 30;
                    const gradient = ctx.createRadialGradient(
                        width / 2, objectY, 0,
                        width / 2, objectY, disturbRadius
                    );
                    gradient.addColorStop(0, 'rgba(180, 150, 100, 0.9)');
                    gradient.addColorStop(1, 'rgba(210, 180, 140, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(width / 2, objectY, disturbRadius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Draw the object (a stone)
                    ctx.beginPath();
                    ctx.arc(width / 2, objectY, 20, 0, Math.PI * 2);
                    ctx.fillStyle = '#555';
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw bubble effects for agitation
                    if (agitation > 0.1) {
                        for (let i = 0; i < agitation * 20; i++) {
                            const bubbleX = width / 2 + (Math.random() - 0.5) * 100;
                            const bubbleY = objectY + Math.random() * 80;
                            const bubbleSize = Math.random() * 4 + 2;
                            
                            ctx.beginPath();
                            ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(250, 250, 250, 0.7)';
                            ctx.fill();
                        }
                    }
                    
                    // Draw explanatory text
                    ctx.fillStyle = 'white';
                    ctx.font = '14px "JetBrains Mono", monospace';
                    ctx.textAlign = 'center';
                    
                    if (cyclePos < 0.5) {
                        ctx.fillText(`Agitating...`, width / 2, height - 20);
                        return "Becomes liquid when agitated!";
                    } else {
                        ctx.fillText(`Settling...`, width / 2, height - 20);
                        return "Thickens when at rest";
                    }
                },
                
                'rheopectic': (ctx, width, height, time) => {
                    // Simulate whipped cream that thickens with prolonged mixing
                    const mixingTime = (time % 10) / 10; // 0 to 1 over 10 seconds
                    const thickness = Math.min(mixingTime * 1.5, 1); // Thickening factor
                    
                    // Draw bowl
                    ctx.beginPath();
                    ctx.ellipse(width / 2, height - 50, width / 3, 40, 0, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw cream
                    ctx.beginPath();
                    ctx.ellipse(width / 2, height - 60, width / 3 - 10, 30, 0, 0, Math.PI);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fill();
                    
                    // Draw mixer/whisk
                    const whiskerY = height - 60 - Math.sin(time * 10) * 10 * (1 - thickness * 0.7);
                    const whiskerHeight = 80;
                    
                    // Draw handle
                    ctx.beginPath();
                    ctx.moveTo(width / 2, whiskerY - whiskerHeight);
                    ctx.lineTo(width / 2, whiskerY);
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 5;
                    ctx.stroke();
                    
                    // Draw whisk wires
                    const wireCount = 4;
                    const wireLength = 20;
                    for (let i = 0; i < wireCount; i++) {
                        const angle = (i / wireCount) * Math.PI * 2;
                        const endX = width / 2 + Math.cos(angle) * wireLength;
                        const endY = whiskerY + Math.sin(angle) * wireLength * 0.5;
                        
                        ctx.beginPath();
                        ctx.moveTo(width / 2, whiskerY);
                        ctx.quadraticCurveTo(
                            width / 2 + Math.cos(angle) * wireLength * 0.6,
                            whiskerY + Math.sin(angle) * wireLength * 0.3,
                            endX, endY
                        );
                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    
                    // Draw cream peaks based on thickness
                    if (thickness > 0.3) {
                        const peakCount = Math.floor(thickness * 15);
                        
                        for (let i = 0; i < peakCount; i++) {
                            const angle = (i / peakCount) * Math.PI * 2 + time * 0.5;
                            const distance = (width / 3 - 20) * (0.7 + Math.random() * 0.3);
                            const peakX = width / 2 + Math.cos(angle) * distance;
                            const peakY = height - 60 + Math.sin(angle) * distance * 0.3;
                            const peakHeight = thickness * 20 * (0.5 + Math.random() * 0.5);
                            
                            ctx.beginPath();
                            ctx.moveTo(peakX, peakY);
                            ctx.quadraticCurveTo(
                                peakX, peakY - peakHeight * 0.7,
                                peakX + Math.random() * 10 - 5, peakY - peakHeight
                            );
                            ctx.quadraticCurveTo(
                                peakX + Math.random() * 10, peakY - peakHeight * 0.7,
                                peakX + Math.random() * 10 - 5, peakY
                            );
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.fill();
                        }
                    }
                    
                    // Draw bubbles/froth
                    for (let i = 0; i < 30; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * (width / 3 - 15);
                        const bubbleX = width / 2 + Math.cos(angle) * distance;
                        const bubbleY = height - 60 + Math.sin(angle) * distance * 0.3;
                        const bubbleSize = Math.random() * 3 + 1;
                        
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.fill();
                    }
                    
                    // Draw explanatory text
                    ctx.fillStyle = 'white';
                    ctx.font = '14px "JetBrains Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Whipping time: ${Math.round(mixingTime * 100)}%`, width / 2, height - 20);
                    
                    return thickness > 0.7 ? "Thickens with prolonged stirring!" : "Initially fluid";
                },
                
                'bingham': (ctx, width, height, time) => {
                    // Simulate toothpaste-like behavior
                    const pressure = (Math.sin(time * 0.5) + 1) / 2; // 0 to 1 cycle
                    
                    // Draw tube
                    const tubeWidth = 70;
                    const tubeHeight = 140;
                    const tubeX = width / 2 - tubeWidth / 2;
                    const tubeY = 20;
                    
                    // Tube body
                    ctx.fillStyle = '#55AAFF';
                    ctx.beginPath();
                    ctx.roundRect(tubeX, tubeY, tubeWidth, tubeHeight, 10);
                    ctx.fill();
                    
                    // Cap
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.roundRect(tubeX + 15, tubeY - 15, tubeWidth - 30, 20, 5);
                    ctx.fill();
                    
                    // Nozzle
                    ctx.fillStyle = '#3388DD';
                    ctx.beginPath();
                    ctx.roundRect(tubeX + 25, tubeY - 5, tubeWidth - 50, 10, 3);
                    ctx.fill();
                    
                    // Draw squeezing effect
                    if (pressure > 0.3) {
                        // Show squeezing
                        const squeezeAmount = pressure * 15;
                        ctx.fillStyle = '#4499EE';
                        ctx.beginPath();
                        ctx.roundRect(
                            tubeX - squeezeAmount / 2, 
                            tubeY, 
                            tubeWidth + squeezeAmount,
                            tubeHeight, 
                            10
                        );
                        ctx.fill();
                        
                        // Draw paste coming out
                        const pasteLength = pressure * 150;
                        if (pasteLength > 10) {
                            // Draw toothpaste coming out
                            const pasteWidth = 20;
                            const startX = width / 2;
                            const startY = tubeY;
                            
                            // Create wavy paste path
                            ctx.beginPath();
                            ctx.moveTo(startX - pasteWidth / 2, startY);
                            
                            const waveAmplitude = 10;
                            const waveFrequency = 0.1;
                            const segments = 20;
                            
                            for (let i = 0; i <= segments; i++) {
                                const t = i / segments;
                                const segmentY = startY + pasteLength * t;
                                const waveOffset = Math.sin(t * 10 + time * 3) * waveAmplitude;
                                const width = pasteWidth * (1 - t * 0.7);
                                
                                if (i === 0) {
                                    ctx.moveTo(startX + waveOffset - width / 2, segmentY);
                                } else {
                                    ctx.lineTo(startX + waveOffset - width / 2, segmentY);
                                }
                            }
                            
                            for (let i = segments; i >= 0; i--) {
                                const t = i / segments;
                                const segmentY = startY + pasteLength * t;
                                const waveOffset = Math.sin(t * 10 + time * 3) * waveAmplitude;
                                const width = pasteWidth * (1 - t * 0.7);
                                
                                ctx.lineTo(startX + waveOffset + width / 2, segmentY);
                            }
                            
                            ctx.closePath();
                            ctx.fillStyle = 'white';
                            ctx.fill();
                            
                            // Add some stripes to the paste
                            ctx.beginPath();
                            const stripeY = startY + pasteLength * 0.3;
                            const stripeWidth = pasteWidth * 0.7;
                            const stripeOffset = Math.sin(time * 3) * waveAmplitude;
                            ctx.moveTo(startX + stripeOffset - stripeWidth / 2, stripeY);
                            ctx.lineTo(startX + stripeOffset + stripeWidth / 2, stripeY);
                            ctx.strokeStyle = '#88EECC';
                            ctx.lineWidth = 5;
                            ctx.stroke();
                        }
                    }
                    
                    // Draw explanatory text
                    ctx.fillStyle = 'white';
                    ctx.font = '14px "JetBrains Mono", monospace';
                    ctx.textAlign = 'center';
                    
                    if (pressure > 0.3) {
                        ctx.fillText(`Applying pressure...`, width / 2, height - 20);
                        return "Flows only above yield stress!";
                    } else {
                        ctx.fillText(`Resting...`, width / 2, height - 20);
                        return "Acts like a solid at rest";
                    }
                }
            };
            
            // Start the fluid demonstration
            function startDemo() {
                if (gameActive) return;
                
                gameActive = true;
                fluidOptions.style.display = 'block';
                startButton.disabled = true;
                
                // Select a random fluid type
                const fluidTypes = Object.keys(fluidAnimations);
                currentFluid = fluidTypes[Math.floor(Math.random() * fluidTypes.length)];
                
                // Create canvas for animation
                const canvas = document.createElement('canvas');
                canvas.width = fluidAnimation.clientWidth;
                canvas.height = fluidAnimation.clientHeight;
                fluidAnimation.innerHTML = '';
                fluidAnimation.appendChild(canvas);
                const ctx = canvas.getContext('2d');
                
                // Start animation loop
                let startTime = Date.now();
                let statusText = '';
                
                function animate() {
                    const time = (Date.now() - startTime) / 1000;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Run current fluid animation
                    statusText = fluidAnimations[currentFluid](ctx, canvas.width, canvas.height, time);
                    fluidDemoText.textContent = statusText;
                    fluidDemoText.style.display = 'block';
                    
                    animationFrame = requestAnimationFrame(animate);
                }
                
                animate();
            }
            
            // Check the player's guess
            function checkGuess(fluidType) {
                if (!gameActive) return;
                
                // Update score
                score.total++;
                if (fluidType === currentFluid) {
                    score.correct++;
                }
                scoreDisplay.textContent = `Score: ${score.correct}/${score.total}`;
                
                // Give feedback
                const resultText = fluidType === currentFluid
                    ? `Correct! That was ${currentFluid}.`
                    : `Incorrect. That was ${currentFluid}.`;
                
                fluidDemoText.textContent = resultText;
                
                // Reset for next round
                gameActive = false;
                setTimeout(() => {
                    cancelAnimationFrame(animationFrame);
                    startDemo();
                }, 2000);
            }
            
            // Set up event handlers
            startButton.addEventListener('click', startDemo);
            
            fluidOptionButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if (!gameActive) return;
                    
                    const fluidType = button.dataset.option;
                    checkGuess(fluidType);
                });
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (gameActive) {
                    cancelAnimationFrame(animationFrame);
                    startDemo();
                }
            });
        })();

        // ========== Quiz ==========
        (function createQuiz() {
            const quizData = [
                {
                    question: "Which non-Newtonian fluid gets thicker when you apply force to it?",
                    options: [
                        "Shear-thickening (dilatant)",
                        "Shear-thinning (pseudoplastic)",
                        "Thixotropic",
                        "Bingham plastic"
                    ],
                    correct: 0
                },
                {
                    question: "Ketchup is an example of which type of non-Newtonian fluid?",
                    options: [
                        "Shear-thickening",
                        "Shear-thinning",
                        "Rheopectic",
                        "Bingham plastic"
                    ],
                    correct: 1
                },
                {
                    question: "What causes the particles in oobleck (cornstarch and water) to resist movement when stress is applied?",
                    options: [
                        "Chemical bonds forming between particles",
                        "Temperature increase making the solution more viscous",
                        "Particle chain formation creating temporary rigid structures",
                        "Molecular breakdown into smaller components"
                    ],
                    correct: 2
                },
                {
                    question: "Which non-Newtonian fluid property is useful for liquid body armor?",
                    options: [
                        "Shear-thinning for flexibility",
                        "Shear-thickening for impact resistance",
                        "Thixotropic for time-dependent protection",
                        "Rheopectic for continuous hardening"
                    ],
                    correct: 1
                },
                {
                    question: "What makes Bingham plastic fluids unique?",
                    options: [
                        "They become less viscous the longer they're shaken",
                        "They solidify when heated",
                        "They require a minimum yield stress to begin flowing",
                        "They never return to their original state after stress"
                    ],
                    correct: 2
                }
            ];

            const examplesQuizData = [
                {
                    question: "Whipped cream thickens with continued agitation. This makes it an example of:",
                    options: [
                        "Shear-thickening",
                        "Shear-thinning",
                        "Thixotropic",
                        "Rheopectic"
                    ],
                    correct: 3
                },
                {
                    question: "Quicksand becomes more fluid when agitated, but thickens when still. This makes it:",
                    options: [
                        "Shear-thickening",
                        "Shear-thinning",
                        "Thixotropic",
                        "Bingham plastic"
                    ],
                    correct: 2
                },
                {
                    question: "Blood flows more easily through narrow vessels when under pressure. This makes it:",
                    options: [
                        "Shear-thickening",
                        "Shear-thinning",
                        "Rheopectic",
                        "Bingham plastic"
                    ],
                    correct: 1
                },
                {
                    question: "Toothpaste stays on your toothbrush until you apply pressure. This makes it:",
                    options: [
                        "Shear-thickening",
                        "Shear-thinning",
                        "Thixotropic",
                        "Bingham plastic"
                    ],
                    correct: 3
                },
                {
                    question: "A mixture of cornstarch and water that lets you run across it is an example of:",
                    options: [
                        "Shear-thickening",
                        "Shear-thinning",
                        "Thixotropic",
                        "Bingham plastic"
                    ],
                    correct: 0
                }
            ];
            
            const startQuizButton = document.getElementById('startQuiz');
            const quizContainer = document.getElementById('quizContainer');
            const questionContainer = document.getElementById('questionContainer');
            const submitAnswerButton = document.getElementById('submitAnswer');
            const nextQuestionButton = document.getElementById('nextQuestion');
            const resultDisplay = document.getElementById('result');
            
            const startExamplesQuizButton = document.getElementById('startExamplesQuiz');
            const examplesContainer = document.getElementById('examplesContainer');
            const exampleQuestionContainer = document.getElementById('exampleQuestionContainer');
            const submitExampleAnswerButton = document.getElementById('submitExampleAnswer');
            const nextExampleButton = document.getElementById('nextExample');
            const exampleResultDisplay = document.getElementById('exampleResult');
            
            let currentQuestionIndex = 0;
            let selectedOption = null;
            let quizScore = 0;
            
            let currentExampleIndex = 0;
            let selectedExampleOption = null;
            let exampleScore = 0;
            
            // Display a question
            function displayQuestion(index) {
                const question = quizData[index];
                
                questionContainer.innerHTML = `
                    <h3 class="question">${index + 1}. ${question.question}</h3>
                    <div class="options">
                        ${question.options.map((option, i) => `
                            <div class="option" data-index="${i}">${option}</div>
                        `).join('')}
                    </div>
                `;
                
                // Add event listeners to options
                document.querySelectorAll('#questionContainer .option').forEach(option => {
                    option.addEventListener('click', () => {
                        document.querySelectorAll('#questionContainer .option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        selectedOption = parseInt(option.dataset.index);
                        submitAnswerButton.disabled = false;
                    });
                });
                
                // Reset state
                submitAnswerButton.style.display = 'inline-block';
                nextQuestionButton.style.display = 'none';
                resultDisplay.style.display = 'none';
                submitAnswerButton.disabled = true;
                selectedOption = null;
            }
            
            // Display an example question
            function displayExample(index) {
                const example = examplesQuizData[index];
                
                exampleQuestionContainer.innerHTML = `
                    <h3 class="question">${index + 1}. ${example.question}</h3>
                    <div class="options">
                        ${example.options.map((option, i) => `
                            <div class="option" data-index="${i}">${option}</div>
                        `).join('')}
                    </div>
                `;
                
                // Add event listeners to options
                document.querySelectorAll('#exampleQuestionContainer .option').forEach(option => {
                    option.addEventListener('click', () => {
                        document.querySelectorAll('#exampleQuestionContainer .option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        selectedExampleOption = parseInt(option.dataset.index);
                        submitExampleAnswerButton.disabled = false;
                    });
                });
                
                // Reset state
                submitExampleAnswerButton.style.display = 'inline-block';
                nextExampleButton.style.display = 'none';
                exampleResultDisplay.style.display = 'none';
                submitExampleAnswerButton.disabled = true;
                selectedExampleOption = null;
            }
            
            // Submit answer and show result
            function submitAnswer() {
                const question = quizData[currentQuestionIndex];
                const options = document.querySelectorAll('#questionContainer .option');
                
                if (selectedOption === question.correct) {
                    quizScore++;
                    resultDisplay.textContent = "Correct! Well done!";
                    resultDisplay.style.backgroundColor = "rgba(0, 255, 0, 0.2)";
                    options[selectedOption].classList.add('correct');
                } else {
                    resultDisplay.textContent = `Incorrect. The correct answer is: ${question.options[question.correct]}`;
                    resultDisplay.style.backgroundColor = "rgba(255, 0, 0, 0.2)";
                    options[selectedOption].classList.add('incorrect');
                    options[question.correct].classList.add('correct');
                }
                
                resultDisplay.style.display = 'block';
                submitAnswerButton.style.display = 'none';
                
                if (currentQuestionIndex < quizData.length - 1) {
                    nextQuestionButton.style.display = 'inline-block';
                } else {
                    nextQuestionButton.textContent = 'See Results';
                    nextQuestionButton.style.display = 'inline-block';
                }
            }
            
            // Submit example answer
            function submitExampleAnswer() {
                const example = examplesQuizData[currentExampleIndex];
                const options = document.querySelectorAll('#exampleQuestionContainer .option');
                
                if (selectedExampleOption === example.correct) {
                    exampleScore++;
                    exampleResultDisplay.textContent = "Correct! Well done!";
                    exampleResultDisplay.style.backgroundColor = "rgba(0, 255, 0, 0.2)";
                    options[selectedExampleOption].classList.add('correct');
                } else {
                    exampleResultDisplay.textContent = `Incorrect. The correct answer is: ${example.options[example.correct]}`;
                    exampleResultDisplay.style.backgroundColor = "rgba(255, 0, 0, 0.2)";
                    options[selectedExampleOption].classList.add('incorrect');
                    options[example.correct].classList.add('correct');
                }
                
                exampleResultDisplay.style.display = 'block';
                submitExampleAnswerButton.style.display = 'none';
                
                if (currentExampleIndex < examplesQuizData.length - 1) {
                    nextExampleButton.style.display = 'inline-block';
                } else {
                    nextExampleButton.textContent = 'See Results';
                    nextExampleButton.style.display = 'inline-block';
                }
            }
            
            // Next question
            function nextQuestion() {
                currentQuestionIndex++;
                
                if (currentQuestionIndex < quizData.length) {
                    displayQuestion(currentQuestionIndex);
                } else {
                    // Show final score
                    questionContainer.innerHTML = `
                        <h3>Quiz Completed!</h3>
                        <p>Your score: ${quizScore} out of ${quizData.length}</p>
                        <p>${getScoreMessage(quizScore, quizData.length)}</p>
                    `;
                    submitAnswerButton.style.display = 'none';
                    nextQuestionButton.style.display = 'none';
                }
            }
            
            // Next example
            function nextExample() {
                currentExampleIndex++;
                
                if (currentExampleIndex < examplesQuizData.length) {
                    displayExample(currentExampleIndex);
                } else {
                    // Show final score
                    exampleQuestionContainer.innerHTML = `
                        <h3>Examples Quiz Completed!</h3>
                        <p>Your score: ${exampleScore} out of ${examplesQuizData.length}</p>
                        <p>${getScoreMessage(exampleScore, examplesQuizData.length)}</p>
                    `;
                    submitExampleAnswerButton.style.display = 'none';
                    nextExampleButton.style.display = 'none';
                }
            }
            
            // Get message based on score
            function getScoreMessage(score, total) {
                const percentage = (score / total) * 100;
                
                if (percentage === 100) {
                    return "Perfect! You're a non-Newtonian fluid expert!";
                } else if (percentage >= 80) {
                    return "Great job! You've got a solid understanding of these strange fluids.";
                } else if (percentage >= 60) {
                    return "Good effort! You know the basics of non-Newtonian fluids.";
                } else {
                    return "Keep learning about these fascinating fluids!";
                }
            }
            
            // Event listeners
            startQuizButton.addEventListener('click', function() {
                quizContainer.classList.add('active');
                startQuizButton.style.display = 'none';
                displayQuestion(currentQuestionIndex);
            });
            
            submitAnswerButton.addEventListener('click', submitAnswer);
            nextQuestionButton.addEventListener('click', nextQuestion);
            
            startExamplesQuizButton.addEventListener('click', function() {
                examplesContainer.classList.add('active');
                startExamplesQuizButton.style.display = 'none';
                displayExample(currentExampleIndex);
            });
            
            submitExampleAnswerButton.addEventListener('click', submitExampleAnswer);
            nextExampleButton.addEventListener('click', nextExample);
        })();
    </script>
</body>
</html>